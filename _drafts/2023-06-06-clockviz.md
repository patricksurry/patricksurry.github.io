---
layout: post
title:  "Daily 24h clock visualization"
date:   2023-06-06
thumbnail: missing.jpg
tags: dataviz
---

[suncalc][suncalc] is a JS library for calculating sun positions

[suncalc]: https://github.com/mourner/suncalc

Things to try:

- just a dot for markers
- thinner spiral stroke but blurred and semi-transparent (less obtrusive)
- hairline timeline could be thicker/thinner or darker/lighter with time dilation
- label for dow/month/day inside circle?
- inner and outer tick labels, or just inner plus am/pm indicator


<style>
svg {
}
.swatch {
    stroke-width: 16;
    stroke-linecap: round;
}
.ticks line {
    stroke: rgba(64, 64, 64, 0.75);
    stroke-width: 4;
    stroke-linecap: round;
}
circle {
    flll: none;
    stroke: #999;
}
text {
    fill: #999;
}
</style>

<svg id="tripcal" width="800" height="960">
</svg>

<svg id="clock" width='600' height='600' viewBox='-300 -300 600 600' transform="scale(1 -1)">
  <filter id="blur2">
    <feGaussianBlur in="SourceGraphic" stdDeviation="0.03" />
  </filter>
</svg>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/luxon@3.3.0/build/global/luxon.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/suncalc@1.9.0/suncalc.min.js"></script>
<script>
const
    R2D = 180/Math.PI,
    hours = d3.range(0, 24 + 1e-6, 5/60),
    angleScale = d3.scaleLinear().domain([0, 24]).range([0, 4*Math.PI]),
    radiusScale = (a) =>
        256 + 10*(a < 3*Math.PI/2 ? -1 : (a > 5*Math.PI/2 ? 1: Math.sin(a))),
    colorScale = (v) => d3.scaleLinear()
        .domain([0, 0.5, 1])
        .range(['#002f80', '#e43414', '#feb92f'])
        (d3.easeSinInOut(v));
//
function hourofday(dt) {
    return dt.getHours() + dt.getMinutes()/60 + dt.getSeconds()/60/60;
}
//
/* note some values are Invalid Date if too far north/south */
const d = SunCalc.getTimes(new Date(), 43.3498, -6.2603), // '2023-01-07'
    night1 = hourofday(d.nightEnd),
    day0 = hourofday(d.goldenHourEnd),
    day1 = hourofday(d.goldenHour),
    night0 = hourofday(d.night);
console.log(d, night1, day0, day1, night0, new Date());
//
function lightScale(h) {
    if (h < night1 || h > night0) return 0;
    else if (h > day0 && h < day1) return 1;
    else if (h < day0) return (h - night1)/(day0 - night1);
    else return (h - night0)/(day1 - night0);
}
//
d3.select('#clock')
    .append('g')
    .classed('swatch', true)
    //.attr('filter', 'url(#blur2)')
    .selectAll('path')
    .data(hours.slice(0, -1))
    .join('path')
    .attr('transform', h => `rotate(-${R2D*angleScale(h)})`)
    .attr('d', (h0, i) => {
        const h1 = hours[i+1],
            [r0, r1] = [h0, h1].map(h => radiusScale(angleScale(h))),
            r = (r0 + r1)/2,
            a = angleScale(h1 - h0),
            x = r1 * Math.sin(a),
            y = r1 * Math.cos(a);
        return `M0,${r0} A ${r} ${r} 0 0 0 ${x} ${y}`
    })
    .style('stroke', h => colorScale(lightScale(h)))
    .sort((a, b) => Math.abs(b - 12) - Math.abs(a - 12));
//
d3.select('#clock')
    .append('g')
    .classed('ticks', true)
    .selectAll('line')
    .data(d3.range(0, 12))
    .join('line')
    .attr('y1', 256-8)
    .attr('y2', 256+8)
    .attr('transform', d => `rotate(${d*30})`);
// draw a pointer, need to invert direction
d3.select('#clock')
    .append('path')
    .attr('d', d3.symbol().type(d3.symbolTriangle).size(0.01))
    .attr('transform', `rotate(-240) translate(0, ${1+radiusScale(240*Math.PI/180)*0.1}) rotate(180)`)
    .style('fill', 'red')

const
    boxSize = 100,
    startDate = luxon.DateTime.fromISO('2023-06-19'),
    endDate = luxon.DateTime.fromISO('2023-07-01'),
    anchorDate = startDate.startOf('week'),
    xoff = d => (d.diff(anchorDate, 'days').as('days') % 7) * boxSize,
    yoff = d => Math.floor(d.diff(anchorDate, 'days').as('days') / 7) * boxSize,
    calDates = luxon.Interval.fromDateTimes(startDate, endDate)
        .splitBy({days: 1}).map(d => d.start);

const cal = d3.select('#tripcal')
    .selectAll('g')
    .data(calDates)
    .join('g')
    .attr('transform', d => `translate(${xoff(d) + boxSize/2}, ${yoff(d) + boxSize/2})`);
cal.append('circle').attr('r', boxSize/2);
cal.append('text').text(d => d.toFormat('EEE d MMM'));
</script>